# CFUP协议
一个基于UDP实现的面向连接可靠传输协议

## 协议文档请看[这里](protocol.md)

## 为什么使用CFUP
* 传输更高效, 更低的延迟, UDP特性, 数据包可以很快抵达对方主机
* 在连接成功之前不会占用连接数量, 避免类似TCP的SYN攻击
* 有数据传输应答和超时重传机制, 以及数据包ID标识, 以确保数据包不混乱以及一定能到达对方主机
* 用更严苛和简单的规则来限制通讯, 有任何问题立即关闭连接, 节省资源占用
* 更灵活的流量控制, 允许自定义窗口大小以及单个数据包长度
* 每10秒(可自定义)进行心跳, 避免TCP长时间不活跃导致连接不稳定
* 本协议基于数据包传输, UDP特性, 避免TCP流的数据边界不明确问题(粘包)
* 允许发送不安全的数据包, 及数据包不需要确认对方收到, 可以立即发送
* 支持大数据包的高效传输, 通过链表包机制自动分割和重组大于常规MTU的数据, 可以传输文件
* 是一个轻量级协议, 可以作为嵌入式使用

## 如何实现的?
* 超时重传, 保证数据一定到达(有发必有答)
  * 所有发送的数据包必须做应答处理
  * 如果规定时间内没有应答会重传
  * 重传超过一定次数仍然没有应答说明网络不佳或对方离线
* 防洪水攻击(将上述规则应用到3次握手)
  * 对方只发送AC数据包
  * 我方回复RC ACK数据包
  * RC ACK数据包没有被应答超时重传
  * 重传超过一定次数, 断开连接, 释放资源
* 数据包防乱序(包ID)
  * 每个非应答数据包包含SID表示该数据序号
  * 在接收窗口中对数据进行排序
  * 然后按顺序触发到应用层
* 传输速度快, 并行发送(UDP特性)
  * 在实际互联网环境中, 链路是复杂的
  * 也就是我可以同时发送很多数据包, 因为他们可能会走不同的路由线路
  * 对方根据SID一一应答即可
* 数据包边界明确, 大数据量传输(UDP特性+链表机制)
  * UDP本身特性是以包为单位
  * 如果要发送的单个数据包超过UDP最大限度(65535字节)
  * CFUP对其进行拆包, 拆成若干个链接起来的子数据包并行发送
  * 对端需要对链表包进行重组, 按照SID的顺序
* 心跳保活
  * 每个一段时间发送一个心跳包, 如果对方应答说明还在线, 可以继续通讯
  * 心跳包应答超时, 超时重传
  * 重传次数过多, 认为网络环境差或你已离线, 断开连接释放资源
* 防止大量半断开状态(1次挥手)
  * TCP中如果只发送一个FIN包然后就没有任何后续, 会导致存在半连接状态而占用资源
  * CFUP使用一次挥手, 只发送一个C NA数据包
  * 如果C NA数据包丢了, 也可通过心跳超时与超过重试次数来正常关闭连接释放资源

综上所述, CFUP通过结合UDP的高效与自定义的可靠传输机制  
旨在解决一些TCP的缺点并且构造一个简单可靠的传输  
提供了一个既灵活又高效, 且易于实现的通讯协议选项  
尤其适合那些需要优化延迟, 控制通讯流程细节或在特定环境下运行的应用  
例如游戏, 音频视频实时传输

## 许可
[MIT](LICENSE)

## 实现
本项目包含一个QT实现版本的CFUP协议  
当然也包括图形化界面, QT版本为6.7.0以上  
开发者们可以以此为参考

## 花絮
这个协议来源于我之前开发的一个叫做CSG的游戏框架(unity 3d联机框架)  
这个框架中有一个简单的UDP可靠传输机制  
后来这个协议从框架单独分裂出来, 并加以完善, 构成今天的CFUP  
最开始名字是CSG framework host Communication Protocol, 缩写CCP  
但是由于CCP又会被翻译成~~中国共产党~~, 所以被迫改名  
最后确定的名字为CSG Framework Universal Protocol, 缩写CFUP
